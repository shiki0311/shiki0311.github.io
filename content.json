{"meta":{"title":"Shiki's Blog","subtitle":"","description":"Shiki's Blog","author":"Shiki","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-08-08T07:55:23.749Z","updated":"2025-08-08T07:55:23.749Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"About me 在职RMer,励志成为一名嵌入式软件工程师 Contact me mail： 3309794460@qq.com Github: https://github.com/shiki0311/"},{"title":"所有标签","date":"2025-08-09T04:21:13.363Z","updated":"2025-08-09T04:21:13.363Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"所有分类","date":"2025-08-08T14:25:51.288Z","updated":"2025-08-08T14:25:51.288Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"【RM】起源嵌入式软件代码规范","slug":"【RM】电控代码规范","date":"2025-07-29T16:00:00.000Z","updated":"2025-08-10T11:56:42.362Z","comments":true,"path":"2025/07/30/【RM】电控代码规范/","permalink":"http://example.com/2025/07/30/%E3%80%90RM%E3%80%91%E7%94%B5%E6%8E%A7%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"本文为起源Origin战队嵌入式软件代码规范V1.0，尚未完善，如有错误，欢迎评论区指正","text":"V1.0 CREATED BY @ 我还是不想动 and @ Shiki 本文为起源Origin战队嵌入式软件代码规范V1.0，主要分为两大部分，分别为代码总体原则和具体代码规范，其中具体代码规范分为必须遵守的编程规则和非强制要求的规则。 代码总体原则 清晰可维护 ​ 在RM中，一般来说除去部分应用层代码（电机控制逻辑、UI绘制等），整体的嵌入式代码框架会沿用很多个赛季，因此要求代码必须清晰简洁、易于维护（你肯定不想退休以后半夜被小灯打电话问你这里写的什么shit)。在C板性能过剩的前提下，代码的可阅读性要高于性能，只有确定性能是瓶颈时，才应该主动优化。 对于RM嵌入式代码，保持可维护性最好的方法就是及时清除废弃代码！！！！ 风格一致 ​ 队伍内保持一致的风格进行开发，可以大幅提升代码交接效率。代码风格具体体现在命名规范、代码格式等，具体下文会阐述。 具体代码规范1. 必须遵守的代码规范 1.1文件1.1.1 新增的代码文件的放置位置 新增文件的类型 在文件资源管理器中的位置 在keil5工程中的位置 freertos任务（XXX_task.c&#x2F;h) &#x2F;项目名&#x2F;Tasks&#x2F; &#x2F;项目名&#x2F;Tasks&#x2F; 供task文件及其他应用层文件调用的板级支持包（bsp_xxx.c&#x2F;h) &#x2F;项目名&#x2F;BSP&#x2F; &#x2F;项目名&#x2F;BSP&#x2F; 第三方中间层库文件（如fifo.c&#x2F;h) &#x2F;项目名&#x2F;support&#x2F; &#x2F;项目名&#x2F;support&#x2F; 除freertos以外的其他应用层代码（如pid.c&#x2F;h) &#x2F;项目名&#x2F;App&#x2F; &#x2F;项目名&#x2F;App&#x2F; 1.1.2 文件头注释 新增头文件&#x2F;源文件尽量在文件最上方添加注释，如： 1234567891011121314/** ****************************************************************************** * @file referee.h * @author Shiki * @version V1.3.0 * @date 2025/03/1 * @brief Header file of referee.c ****************************************************************************** * @attention * * 依据裁判系统 串口协议附录 V1.7 * ****************************************************************************** */ 在vscode中快捷添加文件头注释的方法：使用koroFileHeader插件 1.1.3 头文件 一个规范的头文件例子： INS_Task.h ​ (1) 头文件中适合放置接口的声明，不适合放置实现 ​ 头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。 ​ 要求： ​ 1. 只有源文件内部使用的函数声明不应放在头文件中（此函数不对外开放）。 ​ 2. 只有源文件内部使用的宏、枚举、结构定义尽量不放入头文件中。 ​ 3. 变量定义不应放在头文件中，应放在.c文件中。 ​ 4. 变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。 即使必须使用全局变量，也只应当在.c中定义全局变量，然后在.h中使用extern关键字声明。 ​ (2) 头文件应职责单一，简化依赖 ​ 头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。队内很多现有代码中头文件过大，职责过多，大大增加了维护成本。简化头文件的一个很好的做法是不要包含用不到的头文件！！！！ ​ 反面案例： 1234567891011121314151617181920212223#include &lt;VXWORKS.H&gt;#include &lt;KERNELLIB.H&gt;#include &lt;SEMLIB.H&gt;#include &lt;INTLIB.H&gt;#include &lt;TASKLIB.H&gt;#include &lt;MSGQLIB.H&gt;#include &lt;STDARG.H&gt;#include &lt;FIOLIB.H&gt;#include &lt;STDIO.H&gt;#include &lt;STDLIB.H&gt;#include &lt;CTYPE.H&gt;#include &lt;STRING.H&gt;#include &lt;ERRNOLIB.H&gt;#include &lt;TIMERS.H&gt;#include &lt;MEMLIB.H&gt;#include &lt;TIME.H&gt;#include &lt;WDLIB.H&gt;#include &lt;SYSLIB.H&gt;#include &lt;TASKHOOKLIB.H&gt;#include &lt;REBOOTLIB.H&gt;typedef unsigned short WORD; ​ 这个头文件不但定义了基本数据类型WORD，还包含了stdio.h syslib.h等等不常用的头文件。如果工程中有10000个源文件，而WORD又是每一个文件必须包含的，从而导致stdio.h&#x2F;syslib.h等可能被不必要的展开了几千次，大大增加了工程的编译时间。 ​ (3) 头文件应向稳定的方向包含 ​ 头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。 ​ 就RM嵌入式代码来说，依赖的方向应该是： 应用层（TASK文件夹和APP文件夹下的代码）依赖于中间件（板级支持包和freertos接口），中间件依赖于HAL库。 ​ （4）每一个 .c 文件应有一个同名 .h 文件，用于声明需要对外公开的接口 ​ （5）禁止头文件循环依赖 ​ 头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h&#x2F;b.h&#x2F;c.h的代码全部重新编译一遍。而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h&#x2F;c.h的源代码重新编译。 ​ （6）编写包含保护宏 ​ 在单个源文件中当同一个头文件被多次包含（直接或间接）时，包含保护宏会确保该头文件的内容只被预处理和编译一次，避免重复定义错误。 12#ifndef INS_Task_H#define INS_Task_H 1.1.4 源文件 一个相对规范的源文件例子：Chassis_Task.c 格式化约定 参考：https://sjtu-robomaster-team.github.io/cpp-style-guide/ 缩进和行宽 使用空格，而不是 Tab。 每级缩进使用 4 个空格（也就是说在纯字符串和注释之外的缩进都是 4 的倍数）。 行宽最大为 100。 空行不同的语句之间要么不空行，要么空一行。 123456789void foo() &#123; int x = ...;//空一行 int y = ...; int z = ...;&#125;//空一行void bar() &#123;&#125;void baz() &#123;&#125; 注释 行注释（//）相较于块注释（/* ... */）更好。 当使用行注释时，开头标记后应该有一个空格。 使用行内块注释时，开符号后和闭符号前均有一个空格。多行块注释，开符号后和闭符号前均有一个新行。 行尾注释比其他注释更好。行尾注释之前带有 1 个空格。 应该把块注释当作关键字一样处理其周围的空格。 尾随注释和多行注释任意一行的末尾不应有尾随空格。 12345678// 条目上方的注释struct Foo &#123; ... &#125;;void foo() &#123;&#125; // 条目尾随注释namespace &#123;void foo(/* 参数前的注释 */ T x) &#123;...&#125;&#125; 注释应是完整的句子，行内块注释则不用。 纯注释行的注释宽度不大于 80，且算上缩进总宽度不超过 100。 头文件 源文件 函数 变量、宏、常量 命名（RM习惯）","categories":[],"tags":[{"name":"#RoboMaster","slug":"RoboMaster","permalink":"http://example.com/tags/RoboMaster/"},{"name":"#嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"author":"Shiki"}],"categories":[],"tags":[{"name":"#RoboMaster","slug":"RoboMaster","permalink":"http://example.com/tags/RoboMaster/"},{"name":"#嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}