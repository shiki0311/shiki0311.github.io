{"meta":{"title":"Shiki's Blog","subtitle":"","description":"Shiki's Blog","author":"Shiki","url":"http://example.com","root":"/"},"pages":[{"title":"","date":"2025-08-08T07:55:23.749Z","updated":"2025-08-08T07:55:23.749Z","comments":false,"path":"about/index.html","permalink":"http://example.com/about/index.html","excerpt":"","text":"About me 在职RMer,励志成为一名嵌入式软件工程师 Contact me mail： 3309794460@qq.com Github: https://github.com/shiki0311/"},{"title":"所有分类","date":"2025-08-08T14:25:51.288Z","updated":"2025-08-08T14:25:51.288Z","comments":false,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"所有标签","date":"2025-08-09T04:21:13.363Z","updated":"2025-08-09T04:21:13.363Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"【RM】起源嵌入式软件代码规范","slug":"【RM】电控代码规范","date":"2025-07-29T16:00:00.000Z","updated":"2025-08-12T11:31:32.412Z","comments":true,"path":"2025/07/30/【RM】电控代码规范/","permalink":"http://example.com/2025/07/30/%E3%80%90RM%E3%80%91%E7%94%B5%E6%8E%A7%E4%BB%A3%E7%A0%81%E8%A7%84%E8%8C%83/","excerpt":"本文为起源Origin战队嵌入式软件代码规范V1.0，尚未完善，如有错误，欢迎评论区指正","text":"V1.0 CREATED BY 我还是不想动 and Shiki 本文为起源Origin战队嵌入式软件代码规范V1.0，主要分为两大部分，分别为代码总体原则和具体代码规范，其中具体代码规范分为必须遵守的编程规则和非强制要求的规则。 代码总体原则 清晰可维护 ​ 在RM中，一般来说除去部分应用层代码（电机控制逻辑、UI绘制等），整体的嵌入式代码框架会沿用很多个赛季，因此要求代码必须清晰简洁、易于维护（你肯定不想退休以后半夜被小灯打电话问你这里写的什么shit)。在C板性能过剩的前提下，代码的可阅读性要高于性能，只有确定性能是瓶颈时，才应该主动优化。 对于RM嵌入式代码，保持可维护性最好的方法就是及时清除废弃代码！！！！ 风格一致 ​ 队伍内保持一致的风格进行开发，可以大幅提升代码交接效率。代码风格具体体现在命名规范、代码格式等，具体下文会阐述。 具体代码规范1. 必须遵守的代码规范 1.1文件1.1.1 新增的代码文件的放置位置 新增文件的类型 在文件资源管理器中的位置 在keil5工程中的位置 freertos任务（XXX_task.c&#x2F;h) &#x2F;项目名&#x2F;Tasks&#x2F; &#x2F;项目名&#x2F;Tasks&#x2F; 供task文件及其他应用层文件调用的板级支持包（bsp_xxx.c&#x2F;h) &#x2F;项目名&#x2F;BSP&#x2F; &#x2F;项目名&#x2F;BSP&#x2F; 第三方中间层库文件（如fifo.c&#x2F;h) &#x2F;项目名&#x2F;support&#x2F; &#x2F;项目名&#x2F;support&#x2F; 除freertos以外的其他应用层代码（如pid.c&#x2F;h) &#x2F;项目名&#x2F;App&#x2F; &#x2F;项目名&#x2F;App&#x2F; 1.1.2 文件头注释 新增头文件&#x2F;源文件尽量在文件最上方添加注释，如： 1234567891011121314/** ****************************************************************************** * @file referee.h * @author Shiki * @version V1.3.0 * @date 2025/03/1 * @brief Header file of referee.c ****************************************************************************** * @attention * * 依据裁判系统 串口协议附录 V1.7 * ****************************************************************************** */ 在vscode中快捷添加文件头注释的方法：使用koroFileHeader插件 1.1.3 头文件 一个规范的头文件例子： INS_Task.h （1）头文件中适合放置接口的声明，不适合放置实现 ​ 头文件是模块（Module）或单元（Unit）的对外接口。头文件中应放置对外部的声明，如对外提供的函数声明、宏定义、类型定义等。 ​ 要求： ​ 1. 只有源文件内部使用的函数声明不应放在头文件中（此函数不对外开放）。 ​ 2. 只有源文件内部使用的宏、枚举、结构定义尽量不放入头文件中。 ​ 3. 变量定义不应放在头文件中，应放在.c文件中。 ​ 4. 变量的声明尽量不要放在头文件中，亦即尽量不要使用全局变量作为接口。变量是模块或单元的内部实现细节，不应通过在头文件中声明的方式直接暴露给外部，应通过函数接口的方式进行对外暴露。 即使必须使用全局变量，也只应当在.c中定义全局变量，然后在.h中使用extern关键字声明。 （2）头文件应职责单一，简化依赖 ​ 头文件过于复杂，依赖过于复杂是导致编译时间过长的主要原因。队内很多现有代码中头文件过大，职责过多，大大增加了维护成本。简化头文件的一个很好的做法是不要包含用不到的头文件！！！！ ​ 反面案例： 1234567891011121314151617181920212223#include &lt;VXWORKS.H&gt;#include &lt;KERNELLIB.H&gt;#include &lt;SEMLIB.H&gt;#include &lt;INTLIB.H&gt;#include &lt;TASKLIB.H&gt;#include &lt;MSGQLIB.H&gt;#include &lt;STDARG.H&gt;#include &lt;FIOLIB.H&gt;#include &lt;STDIO.H&gt;#include &lt;STDLIB.H&gt;#include &lt;CTYPE.H&gt;#include &lt;STRING.H&gt;#include &lt;ERRNOLIB.H&gt;#include &lt;TIMERS.H&gt;#include &lt;MEMLIB.H&gt;#include &lt;TIME.H&gt;#include &lt;WDLIB.H&gt;#include &lt;SYSLIB.H&gt;#include &lt;TASKHOOKLIB.H&gt;#include &lt;REBOOTLIB.H&gt;typedef unsigned short WORD; ​ 这个头文件不但定义了基本数据类型WORD，还包含了stdio.h syslib.h等等不常用的头文件。如果工程中有10000个源文件，而WORD又是每一个文件必须包含的，从而导致stdio.h&#x2F;syslib.h等可能被不必要的展开了几千次，大大增加了工程的编译时间。 （3）头文件应向稳定的方向包含 ​ 头文件的包含关系是一种依赖，一般来说，应当让不稳定的模块依赖稳定的模块，从而当不稳定的模块发生变化时，不会影响（编译）稳定的模块。 ​ 就RM嵌入式代码来说，依赖的方向应该是： 应用层（TASK文件夹和APP文件夹下的代码）依赖于中间件（板级支持包和freertos接口），中间件依赖于HAL库。 （4）每一个 .c 文件应有一个同名 .h 文件，用于声明需要对外公开的接口 （5）禁止头文件循环依赖 ​ 头文件循环依赖，指a.h包含b.h，b.h包含c.h，c.h包含a.h之类导致任何一个头文件修改，都导致所有包含了a.h&#x2F;b.h&#x2F;c.h的代码全部重新编译一遍。而如果是单向依赖，如a.h包含b.h，b.h包含c.h，而c.h不包含任何头文件，则修改a.h不会导致包含了b.h&#x2F;c.h的源代码重新编译。 （6）编写时包含保护宏 ​ 在单个源文件中当同一个头文件被多次包含（直接或间接）时，包含保护宏会确保该头文件的内容只被预处理和编译一次，避免重复定义错误。 12#ifndef __INS_Task_H#define __INS_Task_H 1.1.4 源文件 一个相对规范的源文件例子：Chassis_Task.c （1）老生常谈：废弃代码（没有被调用的函数和变量) 要及时清除！！！ （2）与头文件相同，源文件里面也不要包含用不到的头文件！！！ （3）源程序中关系较为紧密的代码应尽可能相邻 例如，功率控制（功率读取、处理功率、输出速度），底盘控制（跟头、解算、电机输出） （4）重复代码应该尽可能提炼成函数 ​ 当一段代码重复两次时，即应考虑消除重复，当代码重复超过三次时，应当立刻着手消除重复。突然增加的新功能容易导致复制粘贴微调，从而代码重复量增加。 在我们的代码中，重复实现的例子有键盘操作、遥控器操作、pid计算等等，这些可以通过封装成函数传入合适参数进行去重复化。 下面这个例子是我发现上赛季的底盘控制任务在底盘跟随云台运动时，在导航模式和遥控器模式下会写一遍一样的逻辑，造成代码冗余。修改后如下： 12345678910111213141516// in Chassis_Task.cstatic void chassis_follow_gimbal_handler(void)&#123; static fp32 chassis_follow_gimbal_zero_actual = CHASSIS_FOLLOW_GIMBAL_ANGLE_ZERO; if (chassis_control.chassis_follow_gimbal_zerochange == TRUE) &#123; chassis_follow_gimbal_zero_actual = Angle_Z_Suit_ZERO_Get(gimbal_m6020[0].ENC_angle); chassis_control.chassis_follow_gimbal_zerochange = FALSE; &#125; chassis_control.chassis_follow_gimbal_angle = Limit_To_180((float)(((uint16_t)gimbal_m6020[0].ENC_angle + (8192 - (uint16_t)chassis_follow_gimbal_zero_actual)) % 8192) / 8192.0f * 360.0f); fp32 chassis_yaw_nearest_zero_rad = -(chassis_control.chassis_follow_gimbal_angle + Limit_To_180((float)(chassis_follow_gimbal_zero_actual - CHASSIS_FOLLOW_GIMBAL_ANGLE_ZERO) / 8192.0f * 360.0f)) / 180.0f * 3.14159f; Set_FollowGimbal_Wz(chassis_control.chassis_follow_gimbal_angle, &amp;chassis_control.wz); Set_Chassis_VxVy(chassis_yaw_nearest_zero_rad, &amp;chassis_control.vx, &amp;chassis_control.vy);&#125; （5）在源文件范围内声明和定义的所有函数，除非外部可见，否则应该增加static关键字 ​ 如果一个函数只是在同一文件中的其他地方调用，那么就用static声明。使用static确保只是在声明它的文件中是可见的，并且避免了 和其他文件或库中的相同标识符发生混淆的可能性。 （6）在源文件范围内使用的结构体，不应声明在头文件 123456789101112131415// in Chassis_Task.ctypedef enum&#123; REMOTE_CONTROL, NAV_NORMAL_MODE, HURT, UPHILL_START, ON_HILL&#125; chassis_max_power_control_t;typedef enum&#123; FOLLOW_GIMBAL, // 底盘跟随云台移动模式 ROTATE, // 小陀螺移动模式 CHASSIS_SAFE // 失能模式&#125; chassis_mode_t; （7）少用全局变量 ​ 在嵌入式开发中，全局变量易于调试，因此很多时候被大量使用。但是对于代码来讲，很多全局变量都是不必要的，并且减少全局变量可以节约flash和SRAM空间。 ​ 减少全局变量的方法：通过函数参数传递数据、使用static限制到更小的作用域内（函数，复合语句，代码块）、将不需要延长生命周期的全局变量变为局部变量。 1234567891011121314151617// in Chassis_Task.cstatic void Chassis_Motor_Data_Update(void)&#123; static const float lpf_ratio = 0.0f; static fp32 chassis_m3508_last_speed[4]; //使用static限制作用域到函数内 for (uint8_t i = 0; i &lt; 4; i++) &#123; chassis_m3508[i].speed = motor_measure_chassis[i].speed_rpm; chassis_m3508[i].speed = (chassis_m3508[i].speed) * (1 - lpf_ratio) + chassis_m3508_last_speed[i] * lpf_ratio; chassis_m3508_last_speed[i] = motor_measure_chassis[i].speed_rpm; &#125;&#125;// 传递结构体指针： 在RTOS中，通过消息队列或任务参数传递数据，而非依赖全局变量：// FreeRTOS 示例xQueueSend(data_queue, &amp;sensor_data, portMAX_DELAY); （6）必须显式初始化变量，严禁使用未经初始化的变量作为右值 ​ 在首次使用前初始化变量，初始化的地方离使用的地方越近越好。 （7）明确全局变量的初始化顺序，避免跨模块的初始化依赖 ​ 系统启动阶段，使用全局变量前，要考虑到该全局变量在什么时候初始化，使用全局变量和初始化全局变量，两者之间的时序关系，谁先谁后，一定要分析清楚，不然后果往往是低级而又灾难性的。 （8）尽量减少没有必要的数据类型默认转换与强制转换 ​ 当进行数据类型强制转换时，其数据的意义、转换后的取值等都有可能发生变化，而这些细节若考虑不周，就很有可能留下隐患。 12345// 错误示例：如下赋值，多数编译器不产生告警，但值的含义还是稍有变化。char ch;unsigned short int exam;ch = -1;exam = ch; // 编译器不产生告警，此时exam为0xFFFF。 1.2 函数（1）一个函数仅完成一件功能 ​ 将没有关联或者关联很弱的语句放到同一函数中，会导致函数职责不明确，难以理解，难以测试和改动。 ​ 一个函数做一件事的例子： 1234567891011// in Gimbal_Task.cvoid Check_Pitch_Electronic_Limit(gimbal_motor_control_mode_t mode)&#123; if ((DM_pitch_motor_data.p_int &lt; PITCH_ECD_ANGLE_MIN &amp;&amp; DM_pitch_motor_data.INS_speed_set &gt; 0) || (DM_pitch_motor_data.p_int &gt; PITCH_ECD_ANGLE_MAX &amp;&amp; DM_pitch_motor_data.INS_speed_set &lt; 0)) &#123; if (mode == POSITION) DM_pitch_motor_data.INS_angle_set = DM_pitch_motor_data.INS_angle; // 位置模式下一越过电子限位，pitch轴目标角度就设置为当前角度 else if (mode == SPEED) DM_pitch_motor_data.INS_speed_set = 0; // 速度模式下一越过电子限位，pitch轴目标速度就设置为0 &#125;&#125; （2）避免函数过长（不超过 50 行的非空非注释行） ​ 过长的函数往往意味着函数功能不单一，过于复杂。 在RM中，某些顺序执行的往往逐渐拓展变长，如一键取矿、飞镖发射,这些函数可以尽量拆成几个功能更细化的函数，如实在无法拆分，也要写清楚注释。 （3）检查函数所有非参数输入的有效性，如数据文件、公共变量等 ​ 函数的输入主要有两种：一种是参数输入；另一种是全局变量、数据文件的输入，即非参数输入。函数在使用输入参数之前，若输入无法保证可靠性，应进行有效性检查。 （4）函数不变参数使用const ​ 不变的值更易于理解&#x2F;跟踪和分析，把const作为默认选项，在编译时会对其进行检查，使代码更牢固&#x2F;更安全。 1234567891011static void chassis_vector_to_mecanum_wheel_speed(const fp32 vx_set, const fp32 vy_set, const fp32 wz_set, fp32 *wheel0, fp32 *wheel1, fp32 *wheel2, fp32 *wheel3, chassis_mode_t mode)&#123; if (wheel0 == NULL || wheel1 == NULL || wheel2 == NULL || wheel3 == NULL || mode == CHASSIS_SAFE) &#123; return; &#125; *wheel0 = (+vx_set + vy_set) - MOTOR_DISTANCE_TO_CENTER * wz_set; *wheel1 = (+vx_set - vy_set) - MOTOR_DISTANCE_TO_CENTER * wz_set; *wheel2 = (-vx_set - vy_set) - MOTOR_DISTANCE_TO_CENTER * wz_set; *wheel3 = (-vx_set + vy_set) - MOTOR_DISTANCE_TO_CENTER * wz_set;&#125; 1.3 命名（1）起源命名标准 小写字母+下划线（snake_case） 全大写+下划线（SCREAMING_SNAKE_CASE） 大驼峰（CamelCase） 小驼峰（camelCase） 代码元素 命名标准 例子 对象宏（符号常量） 全大写+下划线 #define PI_ROUNDED 3.14 宏函数（带参数的宏） 小写字母+下划线，注意用括号保护 #define max(x, y) ((x) &gt; (y) ? (x) : (y)) #define get motor_measure(ptr, data){} 函数名 小写字母+下划线 static void chassis_follow_gimbal_handler(void) 变量 小写字母+下划线 uint16_t current_health; 常量 全大写+下划线 const float PI &#x3D; 3.14159; 类型定义和结构体 小写字母+下划线（类型定义加_t后缀） chassis_control_t chassis_control &#x3D; {0}; typedef unsigned int uint32_t; 枚举类型名 小写字母+下划线+_t typedef enum{ HEALTH_NORMAL, &#x2F;&#x2F; 正常模式 HEALTH_HURT &#x2F;&#x2F; 受伤旋转模式} health_state_t; 枚举值 全大写+下划线 见上 布尔变量&#x2F;函数 使用is_, has_作为前缀 bool is_valid; 指针变量 加p_前缀或ptr后缀 char *p_name; （2）标识符的命名要清晰、明了，有明确含义，同时使用完整的单词或大家基本可以理解的缩写，避免使人产生误解 12345678// GOODuint8_t chassis_control_mode;int error_number;int give_current;// BADuint8_t controlm;int nerr;int g_cur; （3）除了常见的通用缩写以外，不使用单词缩写，不得使用汉语拼音 协议中的单词的缩写与协议保持一致。对于某个系统使用的专用缩写应该在注视或者某处做统一说明。 在RM语境和通用编码语境中，以下缩写被广泛认可： 原单词 缩写 含义 argument arg 参数 buffer buff 缓冲区 clock clk 时钟 command cmd 命令 compare cmp 比较 configuration cfg 配置 device dev 设备 error err 错误 hexadecimal hex 十六进制 increment inc 递增 initialize init 初始化 maximum max 最大值 message msg 消息 minimum min 最小值 parameter para 参数 previous prev 上一个&#x2F;先前的 register reg 寄存器 semaphore sem 信号量 statistic stat 统计 synchronize sync 同步 temp tmp 临时 remote control rc 遥控器 encoder enc 编码器 encoder ecd 编码器（建议统一） Inertial Navigation System ins 惯性导航系统 navigation nav 导航 distance dist 距离 low pass filter lpf 低通滤波器 coefficient coeff 系数 function func 函数 speed spd 速度 average avg 平均 （4）用正确的反义词组命名具有互斥意义的变量或相反动作的函数等 正 反 正 反 add remove lock unlock begin end open close create destroy min max insert delete old new first last start stop get release next previous increment decrement source target put get show hide add delete send receive up down source destination enable disable copy paste （5） 防止局部变量与全局变量同名 尽管局部变量和全局变量的作用域不同而不会发生语法错误，但容易使人误解。 2 非强制要求的规则2.1 源文件（1）if 、 for 、 do 、 while 、 case 、 switch 、 default 等语句独占一行 执行语句必须用缩进风格写，属于if、for、do、while、case、switch、default等下一个缩进级别； 一般写if、for、do、while等语句都会有成对出现的„{}‟，对此有如下建议可以参考 if、for、do、while等语句后的执行语句建议增加成对的“{}” 如果if&#x2F;else配套语句中有一个分支有“{}”，那么另一个分支即使一行代码也建议增加“{}” 添加“{”的位置可以在if等语句后，也可以独立占下一行 独立占下一行时，可以和if在一个缩进级别，也可以在下一个缩进级别 但是如果if语句很长，或者已经有换行，建议“{”使用独占一行的写法。 （2）对于 switch语句下的case语句，如果因为特殊情况需要处理完一个case后进入下一个case处理，必须在该case语句处理完、下一个case语句前加上明确的注释 123456789101112131415161718// 这样比较清楚程序编写者的意图，有效防止无故遗漏break语句。case CMD_FWD: ProcessFwd(); /* now jump into c ase CMD_A */case CMD_A: ProcessA(); break;//对于中间无处理的连续case，已能较清晰说明意图，不强制注释。switch (cmd_flag) &#123; case CMD_A: case CMD_B: &#123; ProcessCMD(); break; &#125; ……&#125; 2.2 函数（1） 设计高扇入，合理扇出（小于7）的函数。 较良好的软件结构通常是顶层函数的扇出较高，中层函数的扇出较少，而底层函数则扇入到公共模块中。 扇出：一个函数直接调用（控制）其它函数的数目 扇入：有多少上级函数调用它 （2）函数的参数个数不超过5个 （3）可重入函数应避免使用共享变量；若需要使用，则应通过互斥手段（关中断、信号量）对其加以保护 可重入函数：可能被多个任务并发调用的函数。 共享变量：全局变量和static变量。 编写C语言的可重入函数时，不应使用static局部变量，否则必须经过特殊处理，才能使函数具有可重入性。 eg： 12345678910111213141516171819202122//不可重入：若被多个线程调用的话，其结果可能是未知的//因为当（**）语句刚执行完后，另外一个使用本函数的线程可能正好被激活，那么当新激活的线程执行到此函数时，将使g_exam赋于另一个不同的para值，所以当控制重新回到“temp =square_exam ( )”后，计算出的temp很可能不是预想中的结果。int g_exam;unsigned int example( int para )&#123; unsigned int temp; g_exam = para; // （**） temp = square_exam ( ); return temp;&#125;//改进int g_exam;unsigned int example( int para )&#123; unsigned int temp; [申请信号量操作] // 若申请不到“信号量”，说明另外的进程正处于 g_exam = para; //给g_exam赋值并计算其平方过程中（即正在使用此 temp = square_exam( g_exam ); // 信号），本进程必须等待其释放信号后，才可继 [释放信号量操作] // 续执行。其它线程必须等待本线程释放信号量后 // 才能再使用本信号。 return temp;&#125; 2.3 结构体（1）保持结构体功能单一 ​ 相关的一组信息才是构成一个结构体的基础，结构的定义应该可以明确的描述一个对象，而不是一组相关性不强的数据的集合。设计结构时应力争使结构代表一种现实事务的抽象，而不是同时代表多种。结构中的各元素应代表同一事务的不同侧面，而不应把描述没有关系或关系很弱的不同事务的元素放到同一结构中。 eg： 1234567891011121314151617181920212223242526typedef struct&#123; float min_angle; // 当前pitch巡航模式下的最小角度 float max_angle; // 当前pitch巡航模式下的最大角度 float step; // 当前pitch巡航模式下每次的步进角度&#125; PitchSwingParams; //pitch导航模式下自主巡航参数结构体typedef struct&#123; fp32 INS_speed; fp32 INS_speed_last; fp32 INS_speed_set; fp32 INS_speed_set_last; fp32 INS_angle; fp32 INS_angle_set; fp32 ENC_angle; fp32 ENC_speed; fp32 ENC_angle_actual; fp32 ENC_angle_set; int16_t give_current; pid_type_def speed_pid; pid_type_def angle_pid; pid_type_def auto_aim_pid;&#125; gimbal_motor_t; // 云台yaw轴6020结构体 2.4 注释 参考：https://sjtu-robomaster-team.github.io/cpp-style-guide/ 行注释（//）相较于块注释（/* ... */）更好。 当使用行注释时，开头标记后应该有一个空格。 使用行内块注释时，开符号后和闭符号前均有一个空格。多行块注释，开符号后和闭符号前均有一个新行。 行尾注释比其他注释更好。行尾注释之前带有 1 个空格。 应该把块注释当作关键字一样处理其周围的空格。 尾随注释和多行注释任意一行的末尾不应有尾随空格。 12345678// 条目上方的注释struct Foo &#123; ... &#125;;void foo() &#123;&#125; // 条目尾随注释namespace &#123;void foo(/* 参数前的注释 */ T x) &#123;...&#125;&#125; 注释应是完整的句子，行内块注释则不用。 纯注释行的注释宽度不大于 80，且算上缩进总宽度不超过 100。 2.5 格式化要求​ 本人是懒狗，亲测github自带的格式化功能够用**（快捷键shift+alt+f)** ，其他格式化要求不过多赘述，好奇的话可以看看交龙代码规范的格式化约定部分","categories":[],"tags":[{"name":"#RoboMaster","slug":"RoboMaster","permalink":"http://example.com/tags/RoboMaster/"},{"name":"#嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}],"author":"Shiki"}],"categories":[],"tags":[{"name":"#RoboMaster","slug":"RoboMaster","permalink":"http://example.com/tags/RoboMaster/"},{"name":"#嵌入式","slug":"嵌入式","permalink":"http://example.com/tags/%E5%B5%8C%E5%85%A5%E5%BC%8F/"}]}